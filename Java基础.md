# Java基础
## 介绍
### Java语言特点
1.简单易学 2.面向对象 3.平台无关性 4.支持多线程 5.可靠安全 6.支持网络编程很方便 7.编译与解释并存

### JVM JDK JRE
JVM是运行Java字节码的虚拟机  
JDK是功能齐全的Java SDK，有编译器javac和工具，可以创建和编译程序。  
JRE是Java运行环境，只能运行Java程序

### 字节码是什么
字节码是源代码`.java`文件被javac编译后生成的`.class`文件，可被JVM解释运行。

### JIT编译器
JIT属于运行时编译，完成第一次编译后，会对字节码对应的机器码保存下来

### 为什么说Java语言“编译与解释并存”？
Java程序要经过先编译，后解释两个步骤，先经过编译步骤，生成字节码，由Java解释器来解释执行

### Java和C++区别
1.Java不提供指针，程序内存更安全  
2.Java的类只支持单继承，C++支持多继承，但Java的接口支持多继承  
3.Java有自动内存管理垃圾回收机制，无需手动释放内存  
4.C++同时支持方法重载和操作符重载，但是Java只支持方法重载

## 基本语法
### Java注释
单行注释 多行注释 文档注释

### 移位运算符
`<<`：左移运算符，相当于乘2  
`>>`：带符号右移运算符，相当于除以2  
`>>>`：无符号右移运算符，相当于除以2  
移位的位数超过数值所占的位数会先进行取余操作在移位

### 变量
#### 成员变量和局部变量  
成员变量是属于类，而局部变量是在代码块或方法中定义的变量或是方法的参数；
成员变量可以被 public,private,static等修饰符修饰， 而局部变量不能被访问控制修饰符和static所修饰；
但是，成员变量和局部变量都能被 final 所修饰。

#### 静态变量
静态变量可以被类的所有实例共享。无论一个类创建了多少个对象，它们都共享同一份静态变量。  
静态变量会被 final 关键字修饰成为常量。

### 方法
#### 静态方法为什么不能调用非静态成员?
静态方法是属于类，在类加载的时候就会分配内存，可以通过类名直接访问。
而非静态成员属于实例对象，只有在对象实例化之后才存在，需要通过类的实例对象去访问。

#### 重载和重写
**重载**是发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同。 

**重写**是子类对父类的允许访问的方法的实现过程进行重新编写。方法名、参数列表必须相同，
子类方法返回值类型应比父类更小或相等，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。
如果父类方法访问修饰符为private/final/static则子类就不能重写该方法，但是被static修饰的方法能够被再次声明。
父类的构造方法不能被重写（重写遵循“两同两小一大”原则）

#### 可变长参数
可变参数只能作为函数的最后一个参数，其前面可以有也可以没有任何其他参数  

遇到方法重载，优先匹配固定参数的方法

### 基本数据类型
byte short int long boolean char float double

#### 基本类型和包装类型
- 成员变量包装类型不赋值就是 null ，而基本类型有默认值且不是 null。  
- 包装类型可用于泛型，而基本类型不可以  
- 基本数据类型的局部变量存放在 Java 虚拟机栈中的局部变量表中,基本数据类型的成员变量（未被 static 修饰 ）存放在 Java 虚拟机的堆中  
包装类型属于对象类型，几乎所有对象实例都存在于堆中。
- 相比于对象类型，基本数据类型占用的空间非常小。

#### 包装类型的缓存机制
Byte,Short,Integer,Long 这 4 种包装类默认创建了数值 [-128，127] 的相应类型的缓存数据，Character 创建了数值在 [0,127] 范围的缓存数据，
Boolean 直接返回 True or False

所有整型包装类对象之间值的比较，全部使用 equals 方法比较。

#### 自动装箱与拆箱
装箱：将基本类型用它们对应的引用类型包装起来（valueOf()）；
拆箱：将包装类型转换为基本数据类型（xxxValue()）；

####解决浮点数运算的精度丢失问题
`BigDecimal`类

#### 超过 long 整型的数据
`BigInteger`类

## 面向对象

### 面向对象和面向过程
- 面向过程把解决问题的过程拆成一个个方法，通过一个个方法的执行解决问题。
- 面向对象会先抽象出对象，然后用对象执行方法的方式解决问题。

### 对象的相等和引用相等
对象的相等一般比较的是内存中存放的内容是否相等。  
引用相等一般比较的是他们指向的内存地址是否相等。

### 构造方法
构造方法不能被重写,但是可以重载，没有声明构造方法也会有默认的不带参数的构造方法

### 面向对象三大特征
#### 封装
封装是指把一个对象的属性隐藏在对象内部，不允许外部对象直接访问对象的内部信息。但是可以提供一些可被外界访问的方法来操作属性

#### 继承
子类拥有父类对象所有的属性和方法，但是父类中的私有属性和方法子类是无法访问，只是拥有。  
子类可以拥有自己属性和方法，即子类可以对父类进行扩展。  
子类可以用自己的方式实现父类的方法

#### 多态
多态，表示一个对象具有多种的状态，具体表现为父类的引用指向子类的实例。

多态的特点：  
引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序运行期间才能确定；  
多态不能调用“只在子类存在但在父类不存在”的方法；  
如果子类重写了父类的方法，真正执行的是子类覆盖的方法，如果子类没有覆盖父类的方法，执行的是父类的方法。

在 Java 中有两种形式可以实现多态：继承（多个子类对同一方法的重写）和接口（实现接口并覆盖接口中同一方法）。

### 接口和抽象类
共同点 ：  
都不能被实例化。  
都可以包含抽象方法。  
都可以有默认实现的方法  

区别 ：  
接口主要用于对类的行为进行约束  
一个类只能继承一个类，但是可以实现多个接口   
接口中的成员变量只能是 public static final 类型的，不能被修改且必须有初始值，而抽象类的成员变量默认 default，可在子类中被重新定义，也可被重新赋值

### 深拷贝和浅拷贝
浅拷贝：浅拷贝会在堆上创建一个新的对象，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址
深拷贝：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。
引用拷贝： 就是两个不同的引用指向同一个对象

## Object类
Object类是所有类的父类。

### == 和 equals() 的区别
对于基本数据类型来说，== 比较的是值。
对于引用数据类型来说，== 比较的是对象的内存地址。

`equals()` 不能用于判断基本数据类型，只能用来判断两个对象是否相等。  
类没有重写 equals()方法，等价于“==”  
类重写了equals()方法，比较两个对象中的属性是否相等

String 中的 equals 方法是被重写过的，比较的是对象的值


### hashCode() 
hashCode() 的作用是获取哈希码（int 整数），也称为散列码。特点是：能根据“键”快速的检索出对应的“值”。

如果两个对象的hashCode值相等，两个对象不一定相等（哈希碰撞）。  
如果两个对象的hashCode值相等并且equals()方法也返回true，两个对象相等。  
如果两个对象的hashCode值不相等，这两个对象不相等。

### 重写 equals() 时必须重写 hashCode() 方法
因为两个相等的对象的 hashCode 值必须是相等。

如果重写 equals() 时没有重写 hashCode() 方法的话就可能会导致 equals 方法判断是相等的两个对象，hashCode值却不相等。

## String
### String、StringBuffer、StringBuilder
String 是不可变的。 StringBuilder 与 StringBuffer没有使用 final 和 private 关键字修饰，是可变的。

String是线程安全，  
StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。  
StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。

使用情况：  
- 操作少量的数据: 用String
- 单线程操作字符串缓冲区下操作大量数据: 用StringBuilder
- 多线程操作字符串缓冲区下操作大量数据: 用StringBuffer

### String + 操作符
字符串对象通过“+”的字符串拼接方式，实际上是通过 StringBuilder 调用 append() 方法实现的，
拼接完成之后调用 toString() 得到一个 String 对象 。

### 字符串常量池
#### String s1 = new String("abc");这句话创建了几个字符串对象？
会创建 1 或 2 个字符串对象。  
1.如果字符串常量池中不存在字符串对象“abc”的引用，那么会在堆中创建 2 个字符串对象“abc”。  
2.如果字符串常量池中已存在字符串对象“abc”的引用，则只会在堆中创建 1 个字符串对象“abc”。

#### intern 方法
作用是将指定的字符串对象的引用保存在字符串常量池中

## 异常
### Exception 和 Error 区别
都有一个共同的祖先 java.lang 包中的 Throwable 类,

### Checked Exception 和 Unchecked Exception 区别？
Checked Exception 即 受检查异常 ，Java 代码在编译过程中，如果受检查异常没有被 catch或者throws 关键字处理的话，就没办法通过编译。  
除了RuntimeException及其子类以外，其他的Exception类及其子类都属于受检查异常 。常见的受检查异常有： IO 相关的异常、ClassNotFoundException 、SQLException...。

Unchecked Exception 即 不受检查异常。RuntimeException 及其子类都统称为非受检查异常

### Throwable 类常用方法
getMessage() toString() getLocalizedMessage() printStackTrace()

### try-catch-finally 
try块 ： 用于捕获异常。其后可接零个或多个 catch 块，如果没有 catch 块，则必须跟一个 finally 块。
catch块 ： 用于处理 try 捕获到的异常。
finally 块 ： 无论是否捕获或处理异常，finally 块里的语句都会被执行。当在 try 块或 catch 块中遇到 return 语句时，finally 语句块将在方法返回之前被执行。

以下 2 种特殊情况下，finally 块的代码也不会被执行：  
程序所在的线程死亡。  
关闭 CPU。  

### try-with-resources
1.适用范围（资源的定义）： 任何实现 java.lang.AutoCloseable或者 java.io.Closeable 的对象  
2.关闭资源和 finally 块的执行顺序： 在 try-with-resources 语句中，任何 catch 或 finally 块在声明的资源关闭后运行

## 泛型
### 使用方式
泛型类、泛型接口、泛型方法。

#### 静态泛型方法
public static <E> void printArray(E[] inputArray)一般被称为静态泛型方法;
由于静态方法的加载先于类的实例化，也就是说类中的泛型还没有传递真正的类型参数，静态的方法的加载就已经完成了，
所以静态泛型方法是没有办法使用类上声明的泛型的。只能使用自己声明的 <E>

## 反射
通过反射你可以获取任意一个类的所有属性和方法，你还可以调用这些方法和属性。

### 反射应用场景
Spring/Spring Boot、MyBatis 等等框架中都大量使用了反射机制。这些框架中也大量使用了动态代理，而动态代理的实现也依赖反射。

Java 中的 注解 的实现也用到了反射

## 注解
Annotation（注解），可以看作是一种特殊的注释，主要用于修饰类、方法或者变量，提供某些信息供程序在编译或者运行时使用。

注解本质是一个继承了Annotation 的特殊接口：

### 注解的解析方法
编译期直接扫描 ：编译器在编译 Java 代码的时候扫描对应的注解并处理，比如某个方法使用@Override 注解，编译器在编译的时候就会检测当前的方法是否重写了父类对应的方法。  
运行期通过反射处理 ：像框架中自带的注解(比如 Spring 框架的 @Value 、@Component)都是通过反射来进行处理的。#

## SPI
SPI 即 Service Provider Interface ，字面意思就是：“服务提供者的接口”

## 序列化和反序列化
序列化： 将数据结构或对象转换成二进制字节流的过程  
反序列化：将在序列化过程中所生成的二进制字节流转换成数据结构或者对象的过程

常用的序列化协议有 Hessian、Kryo、Protobuf、ProtoStuff，这些都是基于二进制的序列化协议。

序列化协议属于 TCP/IP 协议应用层的一部分。

对于不想进行序列化的变量，使用 transient 关键字修饰。

## 语法糖
语法糖（Syntactic sugar） 代指的是编程语言为了方便程序员开发程序而设计的一种特殊语法

举个例子，Java 中的 for-each 就是一个常用的语法糖

JVM 其实并不能识别语法糖，Java 中真正支持语法糖的是 Java 编译器而不是 JVM。

### Java 中常见的语法糖？
泛型、自动拆装箱、变长参数、枚举、内部类、增强 for 循环、try-with-resources 语法、lambda 表达式等。