# Java虚拟机

## 运行时数据区域
### 程序计数器(Program Counter Register)
是当前线程所执行的字节码的行号指示器

### Java虚拟机栈(Java Virtual Machine Stack)
是Java方法执行的线程内存模型。

每个方法被执行的时候，Java虚拟机都 会同步创建一个栈帧(Stack Frame)用于存储局部变量表、操作数栈、动态连接、方法出口等信
息。每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程

### 本地方法栈(Native Method Stacks)
和虚拟机栈所发挥的作用非常相似，区别是： 虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务

### Java堆(Java Heap)
Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。

Java 堆是垃圾收集器管理的主要区域，因此也被称作 GC 堆（Garbage Collected Heap）。从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆还可以细分为：新生代和老年代；再细致一点有：Eden、Survivor、Old 等空间。

### 方法区
是各个线程共享的内存区域，它用于存储已被虚拟机加载 的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。

### 运行时常量池(Runtime Constant Pool)
是方法区的一部分。Class文件中除了有类的版本、字 段、方法、接口等描述信息外，还有一项信息是常量池表(Constant Pool Table)，用于存放编译期生 成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。

### 字符串常量池
是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。

JDK1.7 之前，字符串常量池存放在永久代。JDK1.7 字符串常量池和静态变量从永久代移动了 Java 堆中。

### 直接内存
直接内存是一种特殊的内存缓冲区，并不在 Java 堆或方法区中分配的，而是通过 JNI 的方式在本地内存上分配的

在JDK 1.4中新加入了NIO(New Input/Output)类，引入了一种基于通道(Channel)与缓冲区 (Buffer)的I/O方式，它可以使用Nat ive函数库直接分配堆外内存，然后通过一个存储在Java堆里面的 DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了 在Java堆和Native堆中来回复制数据。

## JVM 垃圾回收
### 判断一个对象是否可被回收
1.引用计数算法:为对象添加一个引用计数器，当对象增加一个引用时计数器加 1，引用失效时计数器减 1。引用计数为 0 的对象可被回收。  
2.可达性分析算法:以 GC Roots 为起始点进行搜索，可达的对象都是存活的，不可达的对象可被回收。
3.方法区的回收:因为方法区主要存放永久代对象，而永久代对象的回收率比新生代低很多，所以在方法区上进行回收性价比不高。 主要是对常量池的回收和对类的卸载。

### 引用类型
1.强引用  
被强引用关联的对象不会被回收。

使用 new 一个新对象的方式来创建强引用。

2.软引用  
被软引用关联的对象只有在内存不够的情况下才会被回收。

使用 SoftReference 类来创建软引用。

3.弱引用
被弱引用关联的对象一定会被回收，也就是说它只能存活到下一次垃圾回收发生之前。

使用 WeakReference 类来创建弱引用。

4. 虚引用
又称为幽灵引用或者幻影引用，一个对象是否有虚引用的存在，不会对其生存时间造成影响，也无法通过虚引用得到一个对象。

为一个对象设置虚引用的唯一目的是能在这个对象被回收时收到一个系统通知。

使用 PhantomReference 来创建虚引用。

### 垃圾收集算法
#### 标记-清除算法
该算法分为“标记”和“清除”阶段：首先标记出所有不需要回收的对象，在标记完成后统一回收掉所有没有被标记的对象。它是最基础的收集算法，后续的算法都是对其不足进行改进得到。

这种垃圾收集算法会带来两个明显的问题：
1.效率问题
2.空间问题（标记清除后会产生大量不连续的碎片）

#### 标记-复制算法
为了解决效率问题，“标记-复制”收集算法出现了。它可以将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。

#### 标记-整理算法
根据老年代的特点提出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。

#### 分代收集算法
根据对象存活周期的不同将内存分为几块。一般将 java 堆分为新生代和老年代

在新生代中，每次收集都会有大量对象死去，所以可以选择”标记-复制“算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。

### 垃圾收集器
Serial 收集器

ParNew 收集器

Parallel Scavenge 收集器

Serial Old 收集器

Parallel Old 收集器

CMS 收集器

Garbage First收集器

## 类加载机制
### 类的生命周期
加载（Loading）   
验证（Verification）  
准备（Preparation）  
解析（Resolution） 
初始化（Initialization）  
使用（Using）  
卸载（Unloading）  




### 类加载过程
包含了加载、验证、准备、解析和初始化这 5 个阶段。

#### 加载
加载过程完成以下三件事：  
- 通过类的完全限定名称获取定义该类的二进制字节流。 
- 将该字节流表示的静态存储结构转换为方法区的运行时存储结构。 
- 在内存中生成一个代表该类的 Class 对象，作为方法区中该类各种数据的访问入口。


#### 验证
确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。

#### 准备
类变量是被 static 修饰的变量，准备阶段为类变量分配内存并设置初始值（初始值一般为 0 值，如果类变量是常量，那么它将初始化为表达式所定义的值而不是 0），使用的是方法区的内存。

实例变量不会在这阶段分配内存，它会在对象实例化时随着对象一起被分配在堆中。应该注意到，实例化不是类加载的一个过程，类加载发生在所有实例化操作之前，并且类加载只进行一次，实例化可以进行多次。

#### 解析
将常量池的符号引用替换为直接引用的过程。 解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用限定符 7 类符号引用进行。

其中解析过程在某些情况下可以在初始化阶段之后再开始，这是为了支持 Java 的动态绑定。

#### 初始化
初始化阶段才真正开始执行类中定义的 Java 程序代码。初始化阶段是虚拟机执行类构造器 <clinit\>() 方法的过程。在准备阶段，类变量已经赋过一次系统要求的初始值，而在初始化阶段，根据程序员通过程序制定的主观计划去初始化类变量和其它资源。

### 类加载的时机
- 遇到new、getstatic、putstatic或invokestatic这四条字节码指令时
- 使用java.lang.reflect包的方法对类型进行反射调用的时候
- 当初始化类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化
- 当虚拟机启动时，用户需要指定一个要执行的主类(包含main()方法的那个类)，虚拟机会先初始化这个主类。

### 类卸载
卸载类即该类的 Class 对象被 GC。

卸载类需要满足 3 个要求:  
1.该类的所有的实例对象都已被 GC，也就是说堆不存在该类的实例对象。  
2.该类没有在其他任何地方被引用  
3.该类的类加载器的实例已被 GC

## 类加载器
类加载器是一个负责加载类的对象，用于实现类加载过程中的加载这一步。  
每个 Java 类都有一个引用指向加载它的 ClassLoader。  
数组类不是通过 ClassLoader 创建的（数组类没有对应的二进制字节流），是由 JVM 直接生成的。  

两个类相等，需要类本身相等，并且使用同一个类加载器进行加载。这是因为每一个类加载器都拥有一个独立的类名称空间

### 类加载器分类
- BootstrapClassLoader(启动类加载器) ：最顶层的加载类，
- ExtensionClassLoader(扩展类加载器) 
- Application ClassLoader(应用程序类加载器)
- 自定义的类加载器

### 双亲委派模型(Parents Delegation Model)
工作过程是:如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加
载这个类，而是把这个请求委派给父类加载器去完成。只有当父加载器反馈自己无法完成这个加载请
求时，子加载器才会尝试自己去完成加载。

#### 双亲委派模型的好处
双亲委派模型保证了 Java 程序的稳定运行，可以避免类的重复加载，也保证了 Java 的核心 API 不被篡改。
