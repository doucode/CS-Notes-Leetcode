[source](https://github.com/Snailclimb/JavaGuide/blob/main/docs/java/basis/java-basic-questions-02.md)
## 面向对象基础

### 面向对象三大特征  
#### 封装
#### 继承  
关于继承如下 3 点请记住：  
1.子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，只是拥有。  
2.子类可以拥有自己属性和方法，即子类可以对父类进行扩展。  
3.子类可以用自己的方式实现父类的方法。

#### 多态  
多态，顾名思义，表示一个对象具有多种的状态，具体表现为父类的引用指向子类的实例。

多态的特点:

- 对象类型和引用类型之间具有继承（类）/实现（接口）的关系；  
- 引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序运行期间才能确定；  
- 多态不能调用“只在子类存在但在父类不存在”的方法；  
- 如果子类重写了父类的方法，真正执行的是子类覆盖的方法，如果子类没有覆盖父类的方法，执行的是父类的方法。

### 接口和抽象类有什么共同点和区别？
共同点 ：  
- 都不能被实例化。  
- 都可以包含抽象方法。  
- 都可以有默认实现的方法

区别 ：  
- 接口主要用于对类的行为进行约束，你实现了某个接口就具有了对应的行为。抽象类主要用于代码复用，强调的是所属关系。  
- 一个类只能继承一个类，但是可以实现多个接口。  
- 接口中的成员变量只能是 public static final 类型的，不能被修改且必须有初始值，而抽象类的成员变量默认 default，可在子类中被重新定义，也可被重新赋值。

### 深拷贝和浅拷贝区别了解吗？什么是引用拷贝？
- 浅拷贝：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。   
- 深拷贝 ：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。

一张图来描述浅拷贝、深拷贝、引用拷贝：
![](https://camo.githubusercontent.com/5734db876243a6b72a80b3cef8584e26fdd8a8c963cc1afaedffdb1f43b73820/68747470733a2f2f67756964652d626c6f672d696d616765732e6f73732d636e2d7368656e7a68656e2e616c6979756e63732e636f6d2f6769746875622f6a61766167756964652f6a6176612f62617369732f7368616c6c6f7726646565702d636f70792e706e67)

## Java 常见类
### Object
#### Object 类的常见方法有哪些？
Object 类是一个特殊的类，是所有类的父类。

#### == 和 equals() 的区别
`==` 对于基本类型和引用类型的作用效果是不同的：

- 对于基本数据类型来说，== 比较的是值。  
- 对于引用数据类型来说，== 比较的是对象的内存地址。

equals() 不能用于判断基本数据类型的变量，只能用来判断两个对象是否相等。equals()方法存在于Object类中，而Object类是所有类的直接或间接父类，因此所有的类都有equals()方法。

#### hashCode() 有什么用？
hashCode()定义在 JDK 的 Object 类中，这就意味着 Java 中的任何类都包含有 hashCode() 函数。另外需要注意的是： Object 的 hashCode() 方法是本地方法

总结下来就是 ：

- 如果两个对象的hashCode 值相等，那这两个对象不一定相等（哈希碰撞）。
- 如果两个对象的hashCode 值相等并且equals()方法也返回 true，我们才认为这两个对象相等。
- 如果两个对象的hashCode 值不相等，我们就可以直接认为这两个对象不相等。

**为什么重写 equals() 时必须重写 hashCode() 方法？**
因为两个相等的对象的 hashCode 值必须是相等。也就是说如果 equals 方法判断两个对象是相等的，那这两个对象的 hashCode 值也要相等。


### String
#### String、StringBuffer、StringBuilder 的区别？
**可变性**

String 是不可变的（后面会详细分析原因）。

StringBuilder 与 StringBuffer 都继承自 AbstractStringBuilder 类

**线程安全性**

String 中的对象是不可变的，也就可以理解为常量，线程安全。AbstractStringBuilder 是 StringBuilder 与 StringBuffer 的公共父类，定义了一些字符串的基本操作，如 expandCapacity、append、insert、indexOf 等公共方法。StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。

**性能**

每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的 String 对象。StringBuffer 每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 StringBuilder 相比使用 StringBuffer 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。

#### 字符串拼接用“+” 还是 StringBuilder?
Java 语言本身并不支持运算符重载，“+”和“+=”是专门为 String 类重载过的运算符，也是 Java 中仅有的两个重载过的运算符。

####String#equals() 和 Object#equals() 有何区别？
String 中的 equals 方法是被重写过的，比较的是 String 字符串的值是否相等。 Object 的 equals 方法是比较的对象的内存地址。



